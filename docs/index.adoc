= Layered Standard for XCP
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:docinfodir: docs
:stylesheet: docs/fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:revdate: unreleased
:revnumber: 1.0
:icons: font

Based on FMI 3.0, this layered standard defines how to describe and implement XCP support for FMUs.

{empty} +
{empty}

Copyright (C) 2012-2022 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intent of This Document

FMI 3.0 was extended also with virtual Electronic Control Units (virtual ECUs) in mind.
Engineers can measure into ECUs using the XCP protocol and A2L variable descriptions:

[quote, ASAM e.V., https://www.asam.net/standards/detail/mcd-1-xcp/[ASAM MCD-1 XCP]]
____
The ASAM MCD-1 XCP (Universal Measurement and Calibration Protocol) standard defines a bus-independent, master-slave communication protocol to connect ECUs with calibration systems.
XCP is short for Universal Measurement and Calibration Protocol.
The primary purpose of XCP is to adjust internal parameters and acquire the current values of internal variables of an ECU.
The first letter X in XCP expresses the fact that the protocol is designed for a variety of bus systems.
The standard consists of a base standard, which describes memory-oriented protocol services without direct dependencies on specific bus systems.
Several associate standards contain the transport layer definitions for CAN, FlexRay, Ethernet (UDP/IP and TCP/IP), serial links (SPI and SCI) and USB.
____

This layered standard describes how an FMU advertises its XCP capabilities to importers and MCD (**M**easurement - **C**alibration - **D**iagnostics) tools using the XCP protocol.

=== How to Read This Document

This document is about how to describe and implement XCP support for FMUs, either by an FMU internal XCP slave implementation or an external XCP slave.
To keep the descriptions brief and redundancy low, <<common-concepts,common concepts>>, which are used by both implementation types, are described once.

The standard document is in HTML allowing use of in-document links.
By pressing "t", the table of contents can be displayed on the left side or hidden.

In key parts of this document, non-normative examples are used to help understand the standard.

Conventions used in this document:

* Non-normative text is given in square brackets in italic font: _[Especially examples are defined in this style.]_

* The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in https://tools.ietf.org/html/rfc2119[RFC 2119] (regardless of formatting and capitalization).

=== Rough Outline of the Approach

There are alternative implementations depending on the use case and data availability:

 . The FMU implements an XCP slave which provides access to measurement and calibration variables of the virtual ECU and handles the communication protocol with the XCP master in the MCD tool.
   The necessary information for an MCD tool is given in a description file which follows the https://www.asam.net/standards/detail/mcd-2-mc/[ASAM MCD-2 MC] standard (aka A2L, also ASAP2) and customarily carries the file extension `.a2l`.
   For further details see <<FMU with Integrated XCP Service>>.
 . An external XCP slave implementation accesses the memory of the virtual ECU to expose the XCP protocol to the MCD tool.
   In this case, the importer needs to provide such an XCP slave implementation together with the A2L description file.
   `fmi3IntermediateUpdateCallback` calls or the clocks mechanism could be used to synchronize DAQ lists.
   For further details see <<External XCP Service>>.

_[It is also possible for an FMU to support both, internal and external XCP services._

_The importer might also use the A2L address, type, layout and scaling information to use direct memory access into the virtual ECU._
_As this approach does not use the standardized XCP protocol it is not further described in this layered standard.]_

=== Comments about this Approach

_[This layered standard will have no effect on the FMU interface, nor the C-API behavior._
_If the XCP slave is implemented inside the FMU, it is recommended that it runs in its own thread and leaves the rest of the operation of the FMU unaffected._

_The A2L/XCP standards allow to measure and calibrate variables synchronously to different types of events._
_These so called event channels are either time-based, angular-based, or non-deterministic, and are identified by a unique event channel number (aka measurement raster)._
_The XCP service must be invoked with the defined event channel number in the thread which is executed for an event._
_Calibration and communication with the XCP master is typically performed in a background thread._
_The background thread must always be responsive to the XCP master within the defined communication timeout._
_Refer to the A2L/XCP standards for more information._

_The XCP/A2L approach can not only be used for virtual ECUs, but also for plant models, if the FMU exporter generates an appropriate A2L file.]_

[#common-concepts]
== Layered Standard Manifest File

This layered standard defines additional capability flags in the layered standard manifest file.
<<fmi-ls-xcp-manifest>> shows the content of `fmi-ls-xcp.manifest`.

.fmi-ls-xcp element.
[#fmi-ls-xcp-manifest]
image::images/schema/fmi-ls-xcp.png[width=60%, align="center"]

.`fmi-ls-xcp` attribute details.
[[table-schema-fmi-ls-xcp-attributes]]
[cols="1,3",options="header"]
|====
|Attribute
|Description

|`version`
| Version of this layered standard the FMU complies with.

|`containsXcpService`
| If `true`, the FMU contains an own XCP slave implementation. See <<FMU with Integrated XCP Service>>.

|`supportsExternalXcpService`
| If `true`, the FMU allows the importer to access its memory via an external XCP service. See <<External XCP Service>>.

|====

== Common Concepts

Independent of the selected implementation approach (see <<Rough Outline of the Approach>>), the XCP behavior as seen by an external MCD tool (XCP master) shall be the same.
The concepts defined in this chapter are common to both of the implementation approaches.
The definitions that are specific to the particular implementation types are defined in <<FMU with Integrated XCP Service>> and <<External XCP Service>>.

=== Structure of the FMU archive

A2L description files and other files needed for XCP support are placed in the `extra` directory: `/extra/org.fmi-standard.fmi-ls-xcp`.
The directory structure is analogous to the `binaries` directory structure and is shown below.
Details are described in the following sections.

[#figure-fmi-layered-XCP-directory-structure]
----
documentation
   fmi-ls-xcp{.txt,.html}          // Informal description how to use XCP/A2L for this FMU (optional).
extra/org.fmi-standard.fmi-ls-xcp  // Contains files related to XCP/A2L
   fmi-ls-xcp.manifest             // The layered standard manifest file
   <modelIdentifier>.a2l           // Variable description of a source code FMU (optional)
   x86_64-windows
      <modelIdentifier>.a2l        // Variable description for Windows on Intel 64-bit (optional)
   x86-linux
      <modelIdentifier>.a2l        // Variable description for Linux on Intel 32-bit (optional)
   aarch32-linux
      <modelIdentifier>.a2l        // Variable description for Linux on ARM 32-bit (optional)
   x86_64-darwin
      <modelIdentifier>.a2l        // Variable description for macOS (optional)
----

=== Documentation

When shipping an FMU with XCP/A2L support, it is recommended to provide the necessary information to the importer in the file `documentation/fmi-ls-xcp.{txt|html}`.
For example, this might concern additional information on how to build the final A2L file, if the FMU is delivered as source code.

=== A2L Description Files

[quote, ASAM e.V., https://www.asam.net/standards/detail/mcd-2-mc/[ASAM MCD-2 MC]]
____
ASAM MCD-2 MC (aka ASAP2) defines the description format of the internal ECU variables used in measurement and calibration.
Measurement & calibration systems (MC-systems) require this description for both the parameterization of scalar constants, curves and maps of the ECU software and for recording the system's response via measurement variables during real-time testing.
The description contains information about data types, dimensions, record layouts and memory locations of ECU variables.
The standard also describes how the variable values are converted into human-readable quantities and displayed in an MC-system.
____

The A2L description depends on the FMU binary, for example, regarding memory addresses, and byte order.
If an FMU archive contains multiple binaries for different platforms, the associated A2L files are placed into separate subdirectories below `/extra/org.fmi-standard.fmi-ls-xcp` following the same scheme as in the `binaries` directory, see <<Structure of the FMU archive>>.

Note that the A2L files placed under the `extra` directory are not accessible to the FMU at runtime.
Any files that shall be accessible to the FMU at runtime must (also) be placed into the `resources` directory as defined by the FMI standard.

A2L files may have a considerable size.
If size is a concern, it may be decided to supply just a single platform and A2L file with an FMU.

The root name of the A2L file shall be identical to the model identifier and is case sensitive, i.e. a variable description named `<modelIdentifier>.a2l` is associated with an FMU binary named `<modelIdentifier>.{dll,so}`.

All format versions of the A2L standard are allowed and it is the responsibility of the MCD tool to handle each format version correctly.

This standard forbids the use of the `including mechanism` of additional A2L files to simplify complete extraction and copying of the A2L file to a location where it is accessible by the MCD tool.

The handling of address information in the A2L file depends on the selected implementation approach for the XCP slave (FMU-internal or external, see <<Rough Outline of the Approach>>) and on the FMU format (binary or source code FMU).
See <<address-resolution-internal>> and <<address-resolution-external>>, respectively, for detailed information about address resolution.

=== XCP Protocol Settings

The A2L description shall include `IF_DATA XCP` elements to help MCD tools to connect and interact with the XCP service of the FMU more reliably and without user interaction.
Parts of the `IF_DATA XCP` description depend on the machine where the FMU binary is executed, for example, the IP address and port.

The default IP address assigned by the FMU exporter shall be `localhost`, i.e. `127.0.0.1`, which fits in many cases.
The requirement for the port number is, that it must be unique on the machine where the FMU binary is executed.
Typically, a certain range of ports is reserved for this purpose.
The FMU importer is responsible for checking if any conflicts of the defined IP addresses and port numbers occur in the context of the simulated system.

In the case of an internal XCP service, it is sometimes necessary for the FMU importer to override the default IP address and/or port number which was assigned by the FMU exporter.
For more information about how to configure and handle the XCP server, see <<configure-internal-xcp-server-settings>>.
In the case of an external XCP service the connection settings are under the control of the importer.

=== Source Code FMUs

An FMU may be delivered as source code together with a `buildDescription.xml` file.
This case requires a common understanding of the A2L workflow between the FMU exporter and importer.
In practice there are different flavors of the workflow depending on the specific use case.

The FMU exporter shall describe the measurement variables (`MEASUREMENT`), calibration parameters (`CHARACTERISTIC`) and related A2L elements of his application in the A2L file.
The A2L file might be fragmentary as the details of the A2L description depend on the binary for the target platform.
Especially the real addresses are not known until the FMU binary is built.
For information on how to deal with memory addresses refer to <<address-resolution-internal>> or <<address-resolution-external>>, respectively.

The A2L description is placed directly into the folder `/extra/org.modelica.fmi-ls-xcp` if it is target-independent, or in target-specific subfolders otherwise (see <<Structure of the FMU archive>>).

The FMU importer is responsible for ensuring that the target-specific information in the A2L file fits to the target platform for which a source code FMU is built.

If additional information for the build process and A2L creation is required, it should be provided by the FMU exporter in documentation/fmi-ls-xcp.{txt|html}.

=== Variable Visibility

The `modelDescription.xml` file publishes a certain set of variables and parameters.
The A2L file also publishes a set of FMU variables and parameters.
This standard expressly does not restrict the relationship between both sets of variables.

_[As a matter of fact, it is quite likely that the variables published in `modelDescription.xml` is a minimal set required for connectivity reasons._
_The A2L file might publish a much larger set of variables and parameters that the user can selectively choose to measure or calibrate._

_From the viewpoint of an MCD tool, the details of the variable access are transparent, i.e. this information is encapsulated in the A2L file.]_

=== Numeric Effects of XCP Access

While measurement of FMU internal variables does not have a numeric effect on the FMU, so called calibration does.
Calibration is the tuning of FMU internal parameters.
Such changes will affect the numeric behavior of the FMU.
If the FMU contains controller code, numeric stability or energy preservation laws are of lesser concern.
On the other hand, plant models offering XCP access for parameter calibration may introduce surprising numerical effects in solvers that might require proper handling, like resetting solvers with every XCP write action.

It is therefore necessary to synchronize XCP variable access (read and write) with the state of the FMU.
_[For instance is time not linear in Model Exchange and Intermediate Variable Access might also introduce surprising measurements in Co-Simulation._
_Appropriate care must be taken when to serve XCP master requests to ensure simulation and measurement integrity.]_

== FMU with Integrated XCP Service

If the XCP slave is implemented in the FMU, the FMU is responsible for handling the communication protocol with the XCP master.
The following sections describe how to configure and handle the internal XCP slave.

The FMU states that it contains an internal XCP slave implementation with the `containsXcpService` attribute in the `fmi-ls-xcp.manifest` file.

_[<<XCP-Communication-via-IP-Stack>> shows a typical design where the XCP slave (in the FMU) communicates with the XCP master (in the MCD tool) using a separate network channel, e.g. the IP stack of the host OS._
_Thus, the communication of the XCP service is not mixed with the simulated network communication of the ECU wrapped in the FMU._
footnote:[The network communication of FMUs is described by another layered standard.
The details of network communication are out of scope here.]

_<<XCP-Communication-via-Virtual-ECU-COM-Stack>> shows an alternative design where the XCP slave communicates via the COM stack of the virtual ECU as in a real ECU._
_In this case, the simulator has to provide access to the simulated network communication for the MCD tool._
_This design may be chosen if the XCP slave implementation is already part of a level-3 ECU code to be tested._
footnote:[The same design could be used to access a diagnostic service, if it is implemented by the ECU code inside the FMU.]

.Direct communication of XCP master and XCP slave via the IP stack of the host OS.
[#XCP-Communication-via-IP-Stack]
image::images/XCP-Communication-via-IP-Stack.svg[width=80%, align="center"]

.Communication of XCP master and XCP slave via the COM stack of the virtual ECU.
[#XCP-Communication-via-Virtual-ECU-COM-Stack]
image::images/XCP-Communication-via-Virtual-ECU-COM-Stack.svg[width=80%, align="center"]

_The implementation of the XCP slave inside the FMU shall only use calls of the host OS, which leave the behavior of the FMU unaffected._
_This concerns, for example, host OS calls_
footnote:[The term 'host OS' means the OS where the FMU process is executed.
This could even be the OS inside a virtual machine connected to the simulator.]
_needed for creation of an own background thread._
_Note that blocking OS calls should be avoided, because they may have an effect on other parts of the simulator outside the FMU.]_

[#configure-internal-xcp-server-settings]
=== Configuring the XCP Protocol Settings

Sometimes it is necessary for the FMU importer to override the default IP address and/or port number which was assigned by the FMU exporter in the A2L file (see <<XCP Protocol Settings>>).
Furthermore, it might be valuable for the user to have the possibility to deactivate the internal XCP service to avoid certain problems with the environment, e.g. with anti-virus software or firewalls or when running the FMU in a container.
The importer might also want to use an external XCP service even when an internal XCP service is available.

Therefore, if the XCP slave is embedded in the virtual ECU, the FMU shall expose three structural parameters with pre-defined names in the `modelDescription.xml`, which are used to configure the embedded XCP slave (see <<starting-internal-xcp-service>>):

.XCP Configuration Parameters
[#figure-xcp-configuration-parameters]
----
   org.fmi-standard.fmi-ls-xcp.EnableInternalXcpService
        Description:  "Determines whether the internal XCP service shall be started."
        Type:         Boolean
        Causality:    structuralParameter
        Variability:  fixed
        Start:        "true"

    org.fmi-standard.fmi-ls-xcp.ListenIpAddress
        Description:  "IP address where the XCP slave listens for XCP protocol commands."
        Type:         String
        Causality:    structuralParameter
        Variability:  fixed
        Start:        "127.0.0.1"

    org.fmi-standard.fmi-ls-xcp.ListenPortNumber
        Description:  "Port number where the XCP slave listens for XCP protocol commands."
        Type:         UInt16
        Causality:    structuralParameter
        Variability:  fixed
        Start:        <in an agreed range of ports, e.g. 32768 to 39999>
----

The importer of an FMU is responsible for keeping all occurrences of the IP address and port number consistent.

[#starting-internal-xcp-service]
=== Starting and Stopping the XCP Service

Since an XCP slave is implemented inside the FMU, the FMU is responsible for starting and stopping the internal XCP service.
Preferably, the FMU shall start the XCP service during `fmi3ExitConfigurationMode` and shut it down during `fmi3Terminate` if the FMU has no explicit power-up signal to simplify user interactions between simulator and MCD tool.
If the FMU contains a virtual ECU with power-up control (K15), all built-in OS and Basic Software services (including XCP) should follow the normal power-up protocol.

If the simulator puts the FMU in `Configuration Mode` and sets the structural parameters `org.fmi-standard.fmi-ls-xcp.ListenIpAddress` and `org.fmi-standard.fmi-ls-xcp.ListenPortNumber`, the XCP slave shall use those parameters to set up the communication connection for the XCP protocol.
If the value of structural parameter `org.fmi-standard.fmi-ls-xcp.EnableInternalXcpService` is `true`, the XCP slave must be responsive for XCP commands after leaving `Configuration Mode`.
Thus, it is possible for the XCP master to perform calibration during the `Instantiated` state, for example, to set parameters before entering `Initialization Mode`.
Note that reading values of calculated variables, which depend on an initialization function, is only possible after entering the `Initialized` super state with `fmi3ExitInitializationMode`.

If `org.fmi-standard.fmi-ls-xcp.EnableInternalXcpService` is `false`, the internal XCP service must not be started and no XCP operations must be performed by the FMU during simulation.

If `Configuration Mode` was not entered and the value of structural parameter `org.fmi-standard.fmi-ls-xcp.EnableInternalXcpService` is `true`, the FMU must start the XCP service in `fmi3EnterInitializationMode` at the latest.
In this case, it is not possible to perform calibration before `Initialization Mode` is entered or to configure the XCP connection settings.

_[If the importer does not support `Configuration Mode` it is not able to control whether or not the internal XCP service shall be started._
_In this case the default value of the `start` attribute of variable `org.fmi-standard.fmi-ls-xcp.EnableInternalXcpService` determines if the XCP service is started.]_

[#address-resolution-internal]
=== Memory Address Resolution

Dependent on the FMU format and the XCP slave implementation inside the FMU, dealing with memory addresses of variables in the A2L file differs.

If the FMU is in binary format, i.e. it is shipped with a shared library, the FMU exporter must provide values for the ECU addresses inside the A2L file and the XCP slave inside the FMU is responsible for resolving the physical addresses from the address field values.
_[These address field values can be either real addresses or fixed target-independent indices that are used by the XCP slave implementation for getting variables during runtime.]_

If the FMU is only shipped with source code, it is not possible to determine the memory addresses before building the binary, i.e. real addresses cannot be provided by the exporter in the A2L file.
In this case the address field values in the A2L file must be either fixed target-independent indices, which allow the FMU to resolve the addresses at runtime, or the A2L file only contains linker symbol links (`SYMBOL_LINK`).
In the latter case, the importer or an external A2L tool is responsible for determining the actual variable addresses from the symbol links.
These addresses must be relative to the base address of the built FMU binary.
Refer to the https://www.asam.net/standards/detail/mcd-2-mc/[ASAM MCD-2 MC] standard for more information on symbol links and automatic address update.

_[Note that, if the FMU exporter does not use real addresses in the A2L file in the binary FMU case, or does not provide symbol links in the source code FMU case, attribute `supportsExternalXcpService` in the `fmi-ls-xcp.manifest` file must be set to `false` (see <<address-resolution-external>>).]_

== External XCP Service

An FMU might support XCP but does not bring along its own XCP slave implementation (attribute `containsXcpService = false` in the `fmi-ls-xcp.manifest` file).
In this case the FMU importer must provide its own implementation of an XCP slave.

It is also possible that the FMU does contain an internal XCP slave implementation but additionally allows the importer to access the memory of the virtual ECU with an external XCP service (attribute `supportsExternalXcpService = true`).
In this case it is the choice of the importer whether to use the FMU internal XCP slave or its own implementation.
See <<starting-internal-xcp-service>> on how to deactivate the internal XCP service.

_[Note that the FMU must set at least one of the attributes `containsXcpService` or `supportsExternalXcpService` to `true` to make use of this layered standard.]_

Although the XCP behavior for an internal and an external service is the same from the perspective of the XCP master, the operation of the external XCP service differs from the internal one in some points that are described in this chapter.

_[<<XCP-Communication-external-Slave>> shows a design where the XCP slave is implemented by the importer outside of the FMU._
_In this variant the XCP communication uses the IP stack of the host OS analogous to the design in <<XCP-Communication-via-IP-Stack>>.]_

.Communication of XCP master and external XCP slave via the IP stack of the host OS.
[#XCP-Communication-external-Slave]
image::images/XCP-Communication-external-Slave.svg[width=80%, align="center"]

[#configure-external-xcp-server-settings]
=== Configuring the XCP Protocol Settings

For an external XCP service no structural parameters for the XCP configuration are needed, because the importer has the entire control over the XCP service and is responsible for its configuration.
_[The importer should allow the user to set IP address and port number analogous to the variant with an internal XCP service.]_

When an external XCP service is used, the importer is the one who has to make XCP service calls and who is responsible for creating events for its XCP service.
However, in contrast to the FMU in the approach with an internal XCP slave, the importer does not necessarily have the knowledge about the inner structure of the virtual ECU and therefore it is not able to create specific events, e.g. one event for each task.

This means, by default, the importer can only make XCP calls at certain points in time disregarding specific task-related XCP events, e.g. at communication points in Co-Simulation.
The importer must create an event channel for this basic measurement raster and must write the corresponding event definition to the `IF_DATA XCP` section in the A2L file.

_[The importer is responsible for matching the `IF_DATA XCP` section in the A2L file to the implementation of the XCP service._
_If necessary, the `IF_DATA XCP` section must be added or replaced in the A2L file delivered with the FMU.]_

If a Co-Simulation FMU announces that it makes use of the intermediate update callback function (attribute `providesIntermediateUpdate = true` of the Co-Simulation element), the importer may also create another event for the intermediate update raster and call the XCP service in each `fmi3IntermediateUpdateCallback` with the event channel number of this event.

Furthermore, if the FMU contains clocks, the importer might also provide the user with the ability to create separate XCP events for each clock.
In this case the simulator is responsible for handling the mapping between clock and XCP event and must call the XCP service with the corresponding event channel when the associated clock is ticking.

[#starting-external-xcp-service]
=== Starting and Stopping the XCP Service

Since the XCP slave is implemented outside the FMU, the importer is responsible for starting and stopping the external XCP service.
_[Preferably, the start-up is performed sometime during the `Instantiated` state of the FMU to allow the XCP master to set parameters before entering `Initialization Mode`.]_

[#address-resolution-external]
=== Memory Address Resolution

Dependent on the FMU format, dealing with memory addresses of variables in the A2L file differs.

Since the used XCP service does not come along with the FMU, it has no knowledge about the address mechanisms that might be used in the A2L file.
Therefore, in the binary FMU case, the A2L file must contain real addresses, which are relative to the base address of the FMU binary.
On the other hand, the external XCP slave must interpret the address values as real addresses as well.

Since the external XCP slave can only make use of real addresses and in the case of source code FMUs there are no real addresses available yet, the A2l file must contain linker symbol links (`SYMBOL_LINK`).
In this case, analogous to the use of an internal XCP slave, the importer or an external A2L tool is responsible for determining the actual variable addresses from the symbol links.

== Known Limitations of This Standard

General limitations:

* This standard forbids the use of the `including mechanism` of additional A2L files to simplify complete extraction and copying of the A2L file to a location where it is accessible by the MCD tool.

* If the FMU contains target-specific binaries _and_ target-specific source code for the same platform, the corresponding A2L files cannot be assigned uniquely.
Therefore, this constellation is not applicable to this layered standard and the FMU exporter must decide between source code and binary files for this platform.

Limitations for binary FMUs:

* Normally only variables in the memory segments owned by the main FMU binary `{.dll, .so}` are accessible by the XCP service, i.e. variables defined in source code modules and in statically linked libraries.
Accessing variables in the memory of indirectly loaded dynamic libraries requires a special implementation which is out-of-scope for this layered standard.

Limitations for variant <<External XCP Service,External XCP Service>>:

* This layered standard does not describe how the importer can determine the different memory segments within the built FMU.
Therefore, page handling is not supported in the case of an external XCP service.
